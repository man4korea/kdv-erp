/* üìÅ js/performance-monitor.js */
/* ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î™®Îìà - KDV ERP ÏãúÏä§ÌÖú */
/* Create at 250525_1330 Ver1.00 */

/**
 * Ïã§ÏãúÍ∞Ñ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÌÅ¥ÎûòÏä§
 * Web Vitals, API ÏùëÎãµÏãúÍ∞Ñ, Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Îì±ÏùÑ Ï∂îÏ†Å
 */
export class PerformanceMonitor {
    constructor() {
        this.metrics = {
            vitals: { fcp: 0, lcp: 0, cls: 0, fid: 0 },
            apiCalls: [],
            memory: { used: 0, total: 0, limit: 0 },
            pageLoads: [],
            errors: []
        };
        this.observers = new Map();
        this.isMonitoring = false;
        this.callbacks = new Map();
        
        // ÏÑ±Îä• ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï
        this.thresholds = {
            fcp: 1800, // First Contentful Paint (1.8Ï¥à)
            lcp: 2500, // Largest Contentful Paint (2.5Ï¥à)
            cls: 0.1,  // Cumulative Layout Shift (0.1)
            fid: 100,  // First Input Delay (100ms)
            apiResponseTime: 2000, // API ÏùëÎãµÏãúÍ∞Ñ (2Ï¥à)
            memoryUsage: 0.8 // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•† (80%)
        };
    }

    /**
     * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
     */
    startMonitoring() {
        if (this.isMonitoring) return;
        
        this.isMonitoring = true;
        console.log('üöÄ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë');
        
        // Core Web Vitals Ï∏°Ï†ï
        this.measureWebVitals();
        
        // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ
        this.monitorMemoryUsage();
        
        // API Ìò∏Ï∂ú Ï∂îÏ†Å
        this.monitorAPIResponses();
        
        // ÌéòÏù¥ÏßÄ Î°úÎî© ÏÑ±Îä• Ï∂îÏ†Å
        this.measurePageLoadPerformance();
        
        // Ï†ïÍ∏∞Ï†Å Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏ (5Ï¥àÎßàÎã§)
        this.metricsInterval = setInterval(() => {
            this.updateMetrics();
        }, 5000);
        
        return true;
    }

    /**
     * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
     */
    stopMonitoring() {
        if (!this.isMonitoring) return;
        
        this.isMonitoring = false;
        console.log('‚èπÔ∏è ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ');
        
        // Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
        }
        
        // ÏòµÏ†ÄÎ≤Ñ Ï†ïÎ¶¨
        this.observers.forEach(observer => {
            if (observer && observer.disconnect) {
                observer.disconnect();
            }
        });
        this.observers.clear();
    }

    /**
     * Core Web Vitals Ï∏°Ï†ï
     */
    measureWebVitals() {
        // First Contentful Paint (FCP)
        new PerformanceObserver((list) => {
            const entries = list.getEntries();
            entries.forEach(entry => {
                if (entry.name === 'first-contentful-paint') {
                    this.metrics.vitals.fcp = Math.round(entry.startTime);
                    this.checkThreshold('fcp', this.metrics.vitals.fcp);
                }
            });
        }).observe({ entryTypes: ['paint'] });

        // Largest Contentful Paint (LCP)
        new PerformanceObserver((list) => {
            const entries = list.getEntries();
            const lastEntry = entries[entries.length - 1];
            this.metrics.vitals.lcp = Math.round(lastEntry.startTime);
            this.checkThreshold('lcp', this.metrics.vitals.lcp);
        }).observe({ entryTypes: ['largest-contentful-paint'] });

        // Cumulative Layout Shift (CLS)
        let clsValue = 0;
        new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (!entry.hadRecentInput) {
                    clsValue += entry.value;
                }
            }
            this.metrics.vitals.cls = Math.round(clsValue * 1000) / 1000;
            this.checkThreshold('cls', this.metrics.vitals.cls);
        }).observe({ entryTypes: ['layout-shift'] });

        // First Input Delay (FID) - ÏÇ¨Ïö©Ïûê ÏÉÅÌò∏ÏûëÏö© Í∞êÏßÄ
        new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                this.metrics.vitals.fid = Math.round(entry.processingStart - entry.startTime);
                this.checkThreshold('fid', this.metrics.vitals.fid);
            }
        }).observe({ entryTypes: ['first-input'] });
    }

    /**
     * Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ
     */
    monitorMemoryUsage() {
        if (!performance.memory) {
            console.warn('‚ö†Ô∏è Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅÏùÄ ChromeÏóêÏÑúÎßå ÏßÄÏõêÎê©ÎãàÎã§');
            return;
        }

        const updateMemory = () => {
            const memory = performance.memory;
            this.metrics.memory = {
                used: Math.round(memory.usedJSHeapSize / 1024 / 1024), // MB
                total: Math.round(memory.totalJSHeapSize / 1024 / 1024), // MB
                limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024) // MB
            };
            
            const usageRatio = this.metrics.memory.used / this.metrics.memory.limit;
            this.checkThreshold('memoryUsage', usageRatio);
        };

        updateMemory();
        setInterval(updateMemory, 3000); // 3Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏
    }

    /**
     * API ÏùëÎãµÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ
     */
    monitorAPIResponses() {
        // XMLHttpRequest Ïò§Î≤ÑÎùºÏù¥Îìú
        const originalXHR = window.XMLHttpRequest;
        const self = this;
        
        window.XMLHttpRequest = function() {
            const xhr = new originalXHR();
            const originalOpen = xhr.open;
            const originalSend = xhr.send;
            
            let startTime, url, method;
            
            xhr.open = function(methodParam, urlParam, ...args) {
                method = methodParam;
                url = urlParam;
                return originalOpen.apply(this, [methodParam, urlParam, ...args]);
            };
            
            xhr.send = function(...args) {
                startTime = performance.now();
                
                xhr.addEventListener('loadend', () => {
                    const endTime = performance.now();
                    const responseTime = Math.round(endTime - startTime);
                    
                    self.recordAPICall({
                        url,
                        method,
                        responseTime,
                        status: xhr.status,
                        timestamp: new Date().toISOString()
                    });
                });
                
                return originalSend.apply(this, args);
            };
            
            return xhr;
        };

        // Fetch API Ïò§Î≤ÑÎùºÏù¥Îìú
        const originalFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            const startTime = performance.now();
            
            return originalFetch.apply(this, arguments).then(response => {
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                self.recordAPICall({
                    url: url.toString(),
                    method: options.method || 'GET',
                    responseTime,
                    status: response.status,
                    timestamp: new Date().toISOString()
                });
                
                return response;
            });
        };
    }

    /**
     * API Ìò∏Ï∂ú Í∏∞Î°ù
     */
    recordAPICall(callData) {
        this.metrics.apiCalls.push(callData);
        
        // ÏµúÍ∑º 50Í∞ú Ìò∏Ï∂úÎßå Ïú†ÏßÄ
        if (this.metrics.apiCalls.length > 50) {
            this.metrics.apiCalls.shift();
        }
        
        this.checkThreshold('apiResponseTime', callData.responseTime);
        
        // ÏΩúÎ∞± Ïã§Ìñâ
        this.executeCallbacks('apiCall', callData);
    }

    /**
     * ÌéòÏù¥ÏßÄ Î°úÎî© ÏÑ±Îä• Ï∏°Ï†ï
     */
    measurePageLoadPerformance() {
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
            const loadData = {
                dnsLookup: Math.round(navigation.domainLookupEnd - navigation.domainLookupStart),
                tcpConnection: Math.round(navigation.connectEnd - navigation.connectStart),
                serverResponse: Math.round(navigation.responseEnd - navigation.requestStart),
                domLoad: Math.round(navigation.domContentLoadedEventEnd - navigation.navigationStart),
                fullLoad: Math.round(navigation.loadEventEnd - navigation.navigationStart),
                timestamp: new Date().toISOString()
            };
            
            this.metrics.pageLoads.push(loadData);
        }
    }

    /**
     * ÏÑ±Îä• ÏûÑÍ≥ÑÍ∞í ÌôïÏù∏ Î∞è Í≤ΩÍ≥†
     */
    checkThreshold(metric, value) {
        const threshold = this.thresholds[metric];
        if (!threshold) return;
        
        let isExceeded = false;
        let message = '';
        
        switch (metric) {
            case 'fcp':
            case 'lcp':
            case 'fid':
            case 'apiResponseTime':
                isExceeded = value > threshold;
                message = `${metric.toUpperCase()}: ${value}ms (ÏûÑÍ≥ÑÍ∞í: ${threshold}ms)`;
                break;
            case 'cls':
                isExceeded = value > threshold;
                message = `CLS: ${value} (ÏûÑÍ≥ÑÍ∞í: ${threshold})`;
                break;
            case 'memoryUsage':
                isExceeded = value > threshold;
                message = `Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†: ${Math.round(value * 100)}% (ÏûÑÍ≥ÑÍ∞í: ${Math.round(threshold * 100)}%)`;
                break;
        }
        
        if (isExceeded) {
            console.warn(`‚ö†Ô∏è ÏÑ±Îä• Í≤ΩÍ≥†: ${message}`);
            this.recordPerformanceWarning(metric, value, message);
        }
    }

    /**
     * ÏÑ±Îä• Í≤ΩÍ≥† Í∏∞Î°ù
     */
    recordPerformanceWarning(metric, value, message) {
        const warning = {
            metric,
            value,
            message,
            timestamp: new Date().toISOString(),
            severity: this.getWarningSeverity(metric, value)
        };
        
        this.metrics.errors.push(warning);
        
        // ÏµúÍ∑º 20Í∞ú Í≤ΩÍ≥†Îßå Ïú†ÏßÄ
        if (this.metrics.errors.length > 20) {
            this.metrics.errors.shift();
        }
        
        // ÏΩúÎ∞± Ïã§Ìñâ
        this.executeCallbacks('performanceWarning', warning);
    }

    /**
     * Í≤ΩÍ≥† Ïã¨Í∞ÅÎèÑ Í≥ÑÏÇ∞
     */
    getWarningSeverity(metric, value) {
        const threshold = this.thresholds[metric];
        const ratio = value / threshold;
        
        if (ratio < 1.2) return 'low';
        if (ratio < 1.5) return 'medium';
        if (ratio < 2.0) return 'high';
        return 'critical';
    }

    /**
     * Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateMetrics() {
        // ÏµúÍ∑º API ÏùëÎãµÏãúÍ∞Ñ ÌèâÍ∑† Í≥ÑÏÇ∞
        const recentAPICalls = this.metrics.apiCalls.slice(-10);
        if (recentAPICalls.length > 0) {
            const avgResponseTime = recentAPICalls.reduce((sum, call) => sum + call.responseTime, 0) / recentAPICalls.length;
            this.metrics.avgApiResponseTime = Math.round(avgResponseTime);
        }
        
        // ÏΩúÎ∞± Ïã§Ìñâ
        this.executeCallbacks('metricsUpdate', this.metrics);
    }

    /**
     * ÌòÑÏû¨ ÏÑ±Îä• Î©îÌä∏Î¶≠ Î∞òÌôò
     */
    getMetrics() {
        return { ...this.metrics };
    }

    /**
     * ÏÑ±Îä• ÏöîÏïΩ Ï†ïÎ≥¥ Î∞òÌôò
     */
    getPerformanceSummary() {
        const recentErrors = this.metrics.errors.filter(error => {
            const errorTime = new Date(error.timestamp);
            const now = new Date();
            return (now - errorTime) < 3600000; // ÏµúÍ∑º 1ÏãúÍ∞Ñ
        });
        
        return {
            webVitals: this.metrics.vitals,
            apiPerformance: {
                totalCalls: this.metrics.apiCalls.length,
                avgResponseTime: this.metrics.avgApiResponseTime || 0,
                slowCalls: this.metrics.apiCalls.filter(call => call.responseTime > this.thresholds.apiResponseTime).length
            },
            memoryUsage: this.metrics.memory,
            warnings: {
                total: this.metrics.errors.length,
                recent: recentErrors.length,
                critical: recentErrors.filter(e => e.severity === 'critical').length
            }
        };
    }

    /**
     * ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ (JSON)
     */
    exportMetrics() {
        return JSON.stringify(this.metrics, null, 2);
    }

    /**
     * ÏΩúÎ∞± Îì±Î°ù
     */
    onMetricsUpdate(callback) {
        if (!this.callbacks.has('metricsUpdate')) {
            this.callbacks.set('metricsUpdate', []);
        }
        this.callbacks.get('metricsUpdate').push(callback);
    }

    onPerformanceWarning(callback) {
        if (!this.callbacks.has('performanceWarning')) {
            this.callbacks.set('performanceWarning', []);
        }
        this.callbacks.get('performanceWarning').push(callback);
    }

    onAPICall(callback) {
        if (!this.callbacks.has('apiCall')) {
            this.callbacks.set('apiCall', []);
        }
        this.callbacks.get('apiCall').push(callback);
    }

    /**
     * ÏΩúÎ∞± Ïã§Ìñâ
     */
    executeCallbacks(event, data) {
        const callbacks = this.callbacks.get(event);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`ÏΩúÎ∞± Ïã§Ìñâ Ïò§Î•ò (${event}):`, error);
                }
            });
        }
    }

    /**
     * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú ÌôïÏù∏
     */
    isActive() {
        return this.isMonitoring;
    }

    /**
     * Î©îÌä∏Î¶≠ Ï¥àÍ∏∞Ìôî
     */
    resetMetrics() {
        this.metrics = {
            vitals: { fcp: 0, lcp: 0, cls: 0, fid: 0 },
            apiCalls: [],
            memory: { used: 0, total: 0, limit: 0 },
            pageLoads: [],
            errors: []
        };
        console.log('üìä ÏÑ±Îä• Î©îÌä∏Î¶≠ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
    }
}

// Ï†ÑÏó≠ ÏÑ±Îä• Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§
export const globalPerformanceMonitor = new PerformanceMonitor();